<!-- -*- nxml -*- -->
<chapter>
  <title>NETCONF Sessions</title>
    <section>
      <title>The NetconfSession Class</title>
      <body>
        <p>
          The <c>NetconfSession</c> class implements the standard
          NETCONF operations.  This class can be extended to implement
          proprietary capabilities and operations The following
          operations are supported:
          <dl termtype="em">
            <dt>get </dt>
            <dd>
              Retrieve running configuration and device state information.
            </dd>
            <dt>getConfig</dt>
            <dd>
              Get the device configuration data.
            </dd>
            <dt>editConfig</dt>
            <dd>
              Edit the configuration on the device.
            </dd>
            <dt>copyConfig </dt>
            <dd>
              Creates or replaces an entire configuration datastore with the
              contents of another complete configuration datastore.  If the
              target datastore exists, it is overwritten.  Otherwise a new one
              is created if allowed.
            </dd>
            <dt>deleteConfig</dt>
            <dd>
              Deletes a configuration datastore.
            </dd>
            <dt>lock</dt>
            <dd>
              The lock operation allows the client to lock the configuration
              system of a device.  Such locks are intended to be short-lived and
              allow a client to make a change without fear of interaction with
              other NETCONF clients, non-NETCONF clients (e.g., SNMP and command
              line interface (CLI) scripts), and human users.       
            </dd>
            <dt>unlock</dt>
            <dd>
              The unlock operation is used to release a configuration lock,
              previously obtained with the <c>lock</c> operation.
            </dd>
            <dt>validate </dt>
            <dd>
              This protocol operation validates the contents of the specified configuration.
            </dd>          
            <dt>commit </dt>
            <dd>
              When a candidate configuration's content is complete, the
              configuration data can be committed, publishing the data set to
              the rest of the device and requesting the device to conform to
              the behavior described in the new configuration.
            </dd>           
            <dt>discardChanges</dt>
            <dd>
              If the client decides that the candidate configuration should not be
              committed, the <c>discardChanges</c> operation can be used to revert the
              candidate configuration to the current running configuration.
            </dd>
            <dt>closeSession</dt>
            <dd>
              Request graceful termination of a NETCONF session.
            </dd>
            <dt>killSession</dt>
            <dd>
              Force the termination of a NETCONF session.
            </dd>
          </dl>
        </p>
      </body>
    </section>
      
    <section>
        <title>Get Configuration</title>
        <body>    
          <p>
            The session will return a configuration tree from many of its 
            operation methods.
            In the example below a subtree filter is built to filter
            the hosts from the configuration.
            The returned "hosts" is really a set of configuration trees, since many 
	    subtrees can match the filter.
	    A NodeSet contains zero or more Elements (subtrees).
          </p>
          <code caption="Get configuration tree using subtree filter"><![CDATA[
Transport tr = new SSHTransport("127.0.0.1", 2022);
tr.authenticateWithPassword("admin", "admin");
NetconfSession sess= new NetconfSession( tr );
ConfElem subtreeFilter = ConfElem.create("http://tail-f.com/ns/simple/1.0","/hosts");
NodeSet reply = sess.get(subtreeFilter);
Element hosts = reply.first();
System.out.println("config tree: "+ hosts.toXMLString() );
]]></code>      


          <p>
            Another way would be to use an XPATH expression instead
            of a subtree filter. 
            This example will return the same result as the example above.
            Not all NETCONF server implementations support the XPATH capability.
          </p>
          <code caption="Get configuration using XPATH filtering"><![CDATA[
Transport tr = new SSHTransport("127.0.0.1", 2022);
tr.authenticateWithPassword("admin", "admin");
NetconfSession sess= new NetconfSession( tr );
NodeSet hosts = sess.get("/hosts");
System.out.println("config tree: "+ hosts.toXMLString() );
]]></code>      
        </body>    
      </section>
      
    <section>
      <title>Transactions Using Candidates Example</title>
      <body>      
        <p>
          Let's assume that we need to update several devices 
          in a transaction based manner. 
          Either all devices are updated or none of them.
          This can be achieved with the <c>confirmedCommit</c> operation,
          which is a commit operation with a specified timeout period.
        </p>
        <p>
          The <c>:confirmed-commit</c> capability indicates that the server
          supports the confirmed commit.
        </p>
        <p>
          A confirmed commit operation must be reverted if a follow-up commit
          (called the "confirming commit") is not issued within 600 seconds (10
          minutes).  The timeout period can be adjusted with the
          timeout parameter. 
        </p>
        <code caption="Transaction using candidates"><![CDATA[
try {
    // Start (NETCONF) sessions towards devices
    Transport ssh1 = new Transport("127.0.0.1","ola","secret");
    Transport ssh2 = new Transport("10.0.0.23","ola","secret");
    NetconfSession dev1 = new NetconfSession(ssh1);
    NetconfSession dev2 = new NetconfSession(ssh2);
 
    // take locks on CANDIDATE datastore so that we are not interrupted
    dev1.lock( NetconfSession.CANDIDATE );
    dev2.lock( NetconfSession.CANDIDATE );
 
    // reset candidates so that CANDIDATE is an exact copy of running
    dev1.copyConfig(NetconfSession.RUNNING, NetconfSession.CANDIDATE);
    dev2.copyConfig(NetconfSession.RUNNING, NetconfSession.CANDIDATE);
 
    // Get system configuration from dev1
    ConfElem sys1 = dev1.getConfig("/system").first();
 
    // Manipulate element trees locally
    sys1.setValue("dns","83.100.1.1");
    sys1.setValue("gateway","10.0.0.1");
 
    // Write back the updated element tree to both devices
    dev1.editConfig( NetconfSession.CANDIDATE, sys1 );
    dev2.editConfig( NetconfSession.CANDIDATE, sys1 );
  
    // candidates are now updated
    dev1.confirmedCommit(60);
    dev2.confirmedCommit(60);
  
    // now commit them
    dev1.commit();
    dev2.commit();
 
    dev1.unlock( NetconfSession.CANDIDATE );
    dev2.unlock( NetconfSession.CANDIDATE );
  
   } catch (Exception e) {
     // Devices will rollback within 1 minute unless the editConfig failed
   }
]]></code>      
      </body>
    </section>  
  </chapter>

